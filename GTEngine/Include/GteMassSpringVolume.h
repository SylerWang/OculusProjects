// Geometric Tools LLC, Redmond WA 98052
// Copyright (c) 1998-2014
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
// File Version: 1.4.0 (2014/09/14)

#pragma once

#include "GteParticleSystem.h"

namespace gte
{

template <int N, typename Real>
class MassSpringVolume : public ParticleSystem<N, Real>
{
public:
    // Construction and destruction.  This class represents an SxRxC array of
    // masses lying on in a volume and connected by an array of springs.  The
    // masses are indexed by mass[s][r][c] for 0 <= s < S, 0 <= r < R, and
    // 0 <= c < C.  The mass at interior position X[s][r][c] is connected by
    // springs to the masses at positions X[s][r-1][c], X[s][r+1][c],
    // X[s][r][c-1], X[s][r][c+1], X[s-1][r][c], and X[s+1][r][c].  Boundary
    // masses have springs connecting them to the obvious neighbors ("face"
    // mass has 5 neighbors, "edge" mass has 4 neighbors, "corner" mass has 3
    // neighbors).  The masses are arranged in lexicographical order:
    // position[c+C*(r+R*s)] = X[s][r][c] for 0 <= s < S, 0 <= r < R, and
    // 0 <= c < C.  The other arrays are stored similarly.
    virtual ~MassSpringVolume();
    MassSpringVolume(int numSlices, int numRows, int numCols, Real step);

    // Member access.
    inline int GetNumSlices() const;
    inline int GetNumRows() const;
    inline int GetNumCols() const;
    inline void SetMass(int s, int r, int c, Real mass);
    inline void SetPosition(int s, int r, int c,
        Vector<N, Real> const& position);
    inline void SetVelocity(int s, int r, int c,
        Vector<N, Real> const& velocity);
    Real const& GetMass(int s, int r, int c) const;
    inline Vector<N, Real> const& GetPosition(int s, int r, int c) const;
    inline Vector<N, Real> const& GetVelocity(int s, int r, int c) const;

    // Each interior mass at (s,r,c) has 6 adjacent springs.  Face masses
    // have only 5 neighbors, edge masses have only 4 neighbors, and corner
    // masses have only 3 neighbors.  Each mass provides access to 3 adjacent
    // springs at (s,r,c+1), (s,r+1,c), and (s+1,r,c).  The face, edge, and
    // corner masses provide access to only an appropriate subset of these.
    // The caller is responsible for ensuring the validity of the (s,r,c)
    // inputs.
    inline void SetConstantS(int s, int r, int c,
        Real constant);  // to (s+1,r,c)
    inline void SetLengthS(int s, int r, int c,
        Real length);    // to (s+1,r,c)
    inline void SetConstantR(int s, int r, int c,
        Real constant);  // to (s,r+1,c)
    inline void SetLengthR(int s, int r, int c,
        Real length);    // to (s,r+1,c)
    inline void SetConstantC(int s, int r, int c,
        Real constant);  // to (s,r,c+1)
    inline void SetLengthC(int s, int r, int c,
        Real length);    // spring to (s,r,c+1)
    inline Real const& GetConstantS(int s, int r, int c) const;
    inline Real const& GetLengthS(int s, int r, int c) const;
    inline Real const& GetConstantR(int s, int r, int c) const;
    inline Real const& GetLengthR(int s, int r, int c) const;
    inline Real const& GetConstantC(int s, int r, int c) const;
    inline Real const& GetLengthC(int s, int r, int c) const;

    // The default external force is zero.  Derive a class from this one to
    // provide nonzero external forces such as gravity, wind, friction,
    // and so on.  This function is called by Acceleration(...) to compute
    // the impulse F/m generated by the external force F.
    virtual Vector<N, Real> ExternalAcceleration(int i, Real time,
        std::vector<Vector<N, Real>> const& position,
        std::vector<Vector<N, Real>> const& velocity);

protected:
    // Callback for acceleration (ODE solver uses x" = F/m) applied to
    // particle i.  The positions and velocities are not necessarily
    // mPosition and mVelocity, because the ODE solver evaluates the
    // impulse function at intermediate positions.
    virtual Vector<N, Real> Acceleration(int i, Real time,
        std::vector<Vector<N, Real>> const& position,
        std::vector<Vector<N, Real>> const& velocity);

    inline int GetIndex(int s, int r, int c) const;
    void GetCoordinates(int i, int& s, int& r, int& c) const;

    int mNumSlices, mNumRows, mNumCols;
    std::vector<Real> mConstantS, mLengthS;
    std::vector<Real> mConstantR, mLengthR;
    std::vector<Real> mConstantC, mLengthC;
};

#include "GteMassSpringVolume.inl"

}
