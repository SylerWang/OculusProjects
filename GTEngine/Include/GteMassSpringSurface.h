// Geometric Tools LLC, Redmond WA 98052
// Copyright (c) 1998-2014
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
// File Version: 1.4.0 (2014/09/14)

#pragma once

#include "GteParticleSystem.h"

namespace gte
{

template <int N, typename Real>
class MassSpringSurface : public ParticleSystem<N, Real>
{
public:
    // Construction and destruction.  This class represents an RxC array of
    // masses lying on a surface and connected by an array of springs.  The
    // masses are indexed by mass[r][c] for 0 <= r < R and 0 <= c < C.  The
    // mass at interior position X[r][c] is connected by springs to the
    // masses at positions X[r-1][c], X[r+1][c], X[r][c-1], and X[r][c+1].
    // Boundary masses have springs connecting them to the obvious neighbors
    // ("edge" mass has 3 neighbors, "corner" mass has 2 neighbors).  The
    // masses are arranged in row-major order:  position[c+C*r] = X[r][c]
    // for 0 <= r < R and 0 <= c < C.  The other arrays are stored similarly.
    virtual ~MassSpringSurface();
    MassSpringSurface(int numRows, int numCols, Real step);

    // Member access.
    inline int GetNumRows() const;
    inline int GetNumCols() const;
    inline void SetMass(int r, int c, Real mass);
    inline void SetPosition(int r, int c, Vector<N, Real> const& position);
    inline void SetVelocity(int r, int c, Vector<N, Real> const& velocity);
    inline Real const& GetMass(int r, int c) const;
    inline Vector<N, Real> const& GetPosition(int r, int c) const;
    inline Vector<N, Real> const& GetVelocity(int r, int c) const;

    // The interior mass at (r,c) has springs to the left, right, bottom, and
    // top.  Edge masses have only three neighbors and corner masses have only
    // two neighbors.  The mass at (r,c) provides access to the springs
    // connecting to locations (r,c+1) and (r+1,c).  Edge and corner masses
    // provide access to only a subset of these.  The caller is responsible
    // for ensuring the validity of the (r,c) inputs.
    inline void SetConstantR(int r, int c, Real constant); // to (r+1,c)
    inline void SetLengthR(int r, int c, Real length);     // to (r+1,c)
    inline void SetConstantC(int r, int c, Real constant); // to (r,c+1)
    inline void SetLengthC(int r, int c, Real length);     // to (r,c+1)
    inline Real const& GetConstantR(int r, int c) const;
    inline Real const& GetLengthR(int r, int c) const;
    inline Real const& GetConstantC(int r, int c) const;
    inline Real const& GetLengthC(int r, int c) const;

    // The default external force is zero.  Derive a class from this one to
    // provide nonzero external forces such as gravity, wind, friction,
    // and so on.  This function is called by Acceleration(...) to compute
    // the impulse F/m generated by the external force F.
    virtual Vector<N, Real> ExternalAcceleration(int i, Real time,
        std::vector<Vector<N, Real>> const& position,
        std::vector<Vector<N, Real>> const& velocity);

protected:
    // Callback for acceleration (ODE solver uses x" = F/m) applied to
    // particle i.  The positions and velocities are not necessarily
    // mPosition and mVelocity, because the ODE solver evaluates the
    // impulse function at intermediate positions.
    virtual Vector<N, Real> Acceleration(int i, Real time,
        std::vector<Vector<N, Real>> const& position,
        std::vector<Vector<N, Real>> const& velocity);

    inline int GetIndex(int r, int c) const;
    void GetCoordinates(int i, int& r, int& c) const;

    int mNumRows, mNumCols;
    std::vector<Real> mConstantR, mLengthR;
    std::vector<Real> mConstantC, mLengthC;
};

#include "GteMassSpringSurface.inl"

}
